#! /usr/bin/env php
<?php
/**
 *
 *===================================================================
 *
 *  Failnet -- PHP-based IRC Bot
 *-------------------------------------------------------------------
 * @version     3.0.0 DEV
 * @category    Failnet
 * @package     build
 * @author      Damian Bushong
 * @copyright   (c) 2009 - 2010 -- Damian Bushong
 * @license     MIT License
 * @link        http://github.com/Obsidian1510/Failnet3
 *
 *===================================================================
 *
 * This source file is subject to the MIT license that is bundled
 * with this package in the file LICENSE.
 *
 */

use Failnet\Lib as Lib;

// This file checks to see if a PHAR archive rebuild is in order.
define('FAILNET', dirname(__FILE__) . '/../');
require FAILNET . 'src/Lib/JSON.php';

// Make it quick.  If there's no JSON file containing file states, then we ought to build anyways.
if(!file_exists(FAILNET . 'build/filestate.json'))
{
	echo "No previous filestate set, rebuild required." . PHP_EOL;
	file_put_contents(FAILNET . 'build/rebuild', '1');
	exit(1);
}

// @note code borrowed from phar-utils
require_once 'Console/CommandLine.php';

// create the parser
$parser = new Console_CommandLine(array(
    'description' => 'Check to see if a PHAR archive rebuild is necessary.',
    'version'     => '0.1.0-dev',
    'name'        => 'build-check',
));

$parser->addOption('src', array(
    'short_name'  => '-s',
    'long_name'   => '--src',
    'action'      => 'StoreString',
    'default'     => './src',
    'description' => "Source files directory\n(./src)"
));

$parser->addOption('exclude_files', array(
    'short_name'  => '-x',
    'long_name'   => '--exclude',
    'action'      => 'StoreString',
    'default'     => '~$',
    'description' => "Space separated regular expressions of filenames that should be excluded\n(\"~$\" by default)"
));

$parser->addOption('exclude_dirs', array(
    'short_name'  => '-X',
    'long_name'   => '--exclude-dir',
    'action'      => 'StoreString',
    'default'     => '/\.svn /\.git',
    'description' => "Space separated regular expressions of directories that should be excluded\n(\"/\.svn /\.git\" by default)"
));

// run the parser
try {
    $result = $parser->parse();
} catch (Exception $exc) {
    $parser->displayError($exc->getMessage());
}

$options = $result->options;

echo $parser->name . ' ' . $parser->version . PHP_EOL . PHP_EOL;

// validate parameters
if (!class_exists('Phar')) {
    $parser->displayError("No Phar support found, you need to build and enable Phar extension. Exiting...", 10);
}

if (!is_dir($options['src']) || !is_readable($options['src'])) {
    $parser->displayError("Source directory in '{$options['src']}' does not exist or is not readable.\n,", 5);
}

try {
	$iterator = new RecursiveDirectoryIterator($options['src']);

    $iterator = new RecursiveIteratorIterator($iterator, RecursiveIteratorIterator::SELF_FIRST);

    if ($options['exclude_files'] || $options['exclude_dirs']) {
        $iterator = new ExcludeFilesIterator($iterator, $options['exclude_files'], $options['exclude_dirs']);
    }

    // buildFromIterator unfortunately sucks and skips nested directories (?)
    foreach ($iterator as $file) {
        //echo "checking " . $file . PHP_EOL;
        if ($file->isFile()) {
            $hash = $checksums[(string) $file] = hash_file('md5', (string) $file);
			//echo "file hash: $hash" . PHP_EOL;
        }
    }

	$filestates = Lib\JSON::decode(FAILNET . 'build/filestate.json');

	foreach($checksums as $file => $checksum) {
		// On the first different thing, bail out and flag this as needing a rebuild.
		if(!isset($filestates[$file]))
		{
			echo "New file '$file' detected, rebuild required.";
			file_put_contents(FAILNET . 'build/rebuild', '1');
			exit(1);
		}
		if($filestates[$file] !== $checksum)
		{
			echo "File '$file' has changed." . PHP_EOL . "Previous checksum: {$filestates[$file]}" . PHP_EOL . "Current checksum: $checksum" . PHP_EOL;
			file_put_contents(FAILNET . 'build/rebuild', '1');
			echo "Rebuild required." . PHP_EOL;
			exit(1);
		}

		unset($filestates[$file], $checksums[$file]);
	}

	// If there were files not present in one filestate or the other, then we obviously need a rebuild.
	if(!empty($checksums) || !empty($filestates))
	{
		echo "One or more files were deleted or added, rebuild required.";
		file_put_contents(FAILNET . 'build/rebuild', '1');
		exit(1);
	}

	file_put_contents(FAILNET . 'build/rebuild', '0');
	echo "Rebuild not required." . PHP_EOL;

} catch (Exception $e) {
    echo "Error: " . $e->getMessage() . "\n";
}

class ExcludeFilesIterator extends FilterIterator {
    protected $exclude_file;
    protected $exclude_path;

    public function __construct(Iterator $i, $exclude_file, $exclude_path) {
        parent::__construct($i);
        $exclude_file = array_map(array($this, 'makeRegExp'), preg_split("/ +/", $exclude_file, -1, PREG_SPLIT_NO_EMPTY));
        $exclude_path = array_map(array($this, 'makeRegExp'), preg_split("/ +/", $exclude_path, -1, PREG_SPLIT_NO_EMPTY));
        $this->exclude_file = $exclude_file;
        $this->exclude_path = $exclude_path;
    }

    protected function makeRegExp($pattern) {
        return '!' . $pattern . '!';
    }

    public function accept() {
        $file = $this->current();
        if ($file->isFile()) {
            foreach ($this->exclude_file as $pattern) {
                if (preg_match($pattern, $file->getFilename())) {
                    //echo "skipping $file\n";
                    return false;
                }
            }
        }

        foreach ($this->exclude_path as $pattern) {
            if (preg_match($pattern, $file->getPathname())) {
                //echo "skipping $file\n";
                return false;
            }
        }

        return true;
    }
}
