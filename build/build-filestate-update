#! /usr/bin/env php
<?php
/**
 *
 *===================================================================
 *
 *  Failnet -- PHP-based IRC Bot
 *-------------------------------------------------------------------
 * @version     3.0.0 DEV
 * @category    Failnet
 * @package     build
 * @author      Damian Bushong
 * @copyright   (c) 2009 - 2010 -- Damian Bushong
 * @license     MIT License
 * @link        http://github.com/Obsidian1510/Failnet3
 *
 *===================================================================
 *
 * This source file is subject to the MIT license that is bundled
 * with this package in the file LICENSE.
 *
 */

use Failnet\Lib as Lib;

// This file checks to see if a PHAR archive rebuild is in order.
define('FAILNET', dirname(__FILE__) . '/../');
require FAILNET . 'src/Lib/JSON.php';

// @note code borrowed from phar-utils
require_once 'Console/CommandLine.php';

// create the parser
$parser = new Console_CommandLine(array(
    'description' => 'Builds a set of file checksums, for determining if a rebuild is needed.',
    'version'     => '0.1.0-dev',
    'name'        => 'build-filestate-update',
));

$parser->addOption('src', array(
    'short_name'  => '-s',
    'long_name'   => '--src',
    'action'      => 'StoreString',
    'default'     => './src',
    'description' => "Source files directory\n(./src)"
));

$parser->addOption('exclude_files', array(
    'short_name'  => '-x',
    'long_name'   => '--exclude',
    'action'      => 'StoreString',
    'default'     => '~$',
    'description' => "Space separated regular expressions of filenames that should be excluded\n(\"~$\" by default)"
));

$parser->addOption('exclude_dirs', array(
    'short_name'  => '-X',
    'long_name'   => '--exclude-dir',
    'action'      => 'StoreString',
    'default'     => '/\.svn /\.git',
    'description' => "Space separated regular expressions of directories that should be excluded\n(\"/\.svn /\.git\" by default)"
));

// run the parser
try {
    $result = $parser->parse();
} catch (Exception $exc) {
    $parser->displayError($exc->getMessage());
}

$options = $result->options;

echo $parser->name . ' ' . $parser->version . PHP_EOL . PHP_EOL;

// validate parameters
if (!class_exists('Phar')) {
    $parser->displayError("No Phar support found, you need to build and enable Phar extension. Exiting...", 10);
}

if (!is_dir($options['src']) || !is_readable($options['src'])) {
    $parser->displayError("Source directory in '{$options['src']}' does not exist or is not readable.\n,", 5);
}

try {
	$iterator = new RecursiveDirectoryIterator($options['src']);

    $iterator = new RecursiveIteratorIterator($iterator, RecursiveIteratorIterator::SELF_FIRST);

    if ($options['exclude_files'] || $options['exclude_dirs']) {
        $iterator = new ExcludeFilesIterator($iterator, $options['exclude_files'], $options['exclude_dirs']);
    }

    // buildFromIterator unfortunately sucks and skips nested directories (?)
    foreach ($iterator as $file) {
        echo "checking " . $file . PHP_EOL;
        if ($file->isFile()) {
            $hash = $checksums[(string) $file] = hash_file('md5', (string) $file);
			//echo "file hash: $hash" . PHP_EOL;
        }
    }

	echo "Storing filestate checksums." . PHP_EOL;
	file_put_contents(FAILNET . 'build/filestate.json', Lib\JSON::encode($checksums));

	$filestates = Lib\JSON::decode(FAILNET . 'build/filestate.json');
} catch (Exception $e) {
    echo "Error: " . $e->getMessage() . "\n";
}

class ExcludeFilesIterator extends FilterIterator {
    protected $exclude_file;
    protected $exclude_path;

    public function __construct(Iterator $i, $exclude_file, $exclude_path) {
        parent::__construct($i);
        $exclude_file = array_map(array($this, 'makeRegExp'), preg_split("/ +/", $exclude_file, -1, PREG_SPLIT_NO_EMPTY));
        $exclude_path = array_map(array($this, 'makeRegExp'), preg_split("/ +/", $exclude_path, -1, PREG_SPLIT_NO_EMPTY));
        $this->exclude_file = $exclude_file;
        $this->exclude_path = $exclude_path;
    }

    protected function makeRegExp($pattern) {
        return '!' . $pattern . '!';
    }

    public function accept() {
        $file = $this->current();
        if ($file->isFile()) {
            foreach ($this->exclude_file as $pattern) {
                if (preg_match($pattern, $file->getFilename())) {
                    //echo "skipping $file\n";
                    return false;
                }
            }
        }

        foreach ($this->exclude_path as $pattern) {
            if (preg_match($pattern, $file->getPathname())) {
                //echo "skipping $file\n";
                return false;
            }
        }

        return true;
    }
}
